{"version":3,"sources":["zindex.ts","index.tsx"],"names":["moveOneLeft","elements","indicesToMove","sort","a","b","isSorted","forEach","index","i","indexA","indexB","element","swap","moveAllLeft","leftMostElements","map","reversedIndicesToMove","reverse","concat","pos","Array","of","randomSeed","Math","floor","random","withCustomMathRandom","seed","cb","imul","LCG","result","distanceBetweenPointAndSegment","x","y","x1","y1","x2","y2","xx","yy","C","D","lenSquare","param","dx","dy","hypot","renderScene","rc","context","sceneState","fillStyle","viewBackgroundColor","fillRect","canvas","width","height","clearRect","draw","isSelected","elementX1","getElementAbsoluteX1","elementX2","getElementAbsoluteX2","elementY1","getElementAbsoluteY1","elementY2","getElementAbsoluteY2","lineDash","getLineDash","setLineDash","strokeRect","scrollX","scrollY","margin","scrollBars","canvasWidth","canvasHeight","scrollBarWidth","abs","horizontalScrollBar","SCROLLBAR_MARGIN","scrollBarHeight","horizontal","vertical","SCROLLBAR_WIDTH","getScrollbars","rotate","angle","cos","sin","generator","rough","isTextElement","type","getArrowPoints","distance","minSize","min","xs","ys","PI","x3","y3","generateDraw","shape","rectangle","stroke","strokeColor","fill","backgroundColor","translate","ellipse","x4","y4","shapes","line","Error","font","fillText","text","actualBoundingBoxAscent","clearSelection","deleteSelectedElements","length","splice","KEYS","SHAPES","icon","faMousePointer","value","faSquare","faCircle","faLongArrowAltRight","faFont","shapesShortcutKeys","findElementByKey","key","reduce","isArrowKey","keyCode","getSelectedIndices","selectedIndices","push","App","state","draggingElement","elementType","exportBackground","exportVisibleOnly","exportPadding","currentItemStrokeColor","currentItemBackgroundColor","onResize","forceUpdate","onKeyDown","event","target","nodeName","preventDefault","step","shiftKey","metaKey","altKey","code","includes","toLowerCase","setState","document","addEventListener","this","window","savedState","savedElements","localStorage","getItem","JSON","parse","e","restore","removeEventListener","className","onCut","clipboardData","setData","stringify","filter","onCopy","onPaste","parsedElements","paste","getData","isArray","parsedElement","checked","onChange","onClick","alert","ReactDOM","render","rootElement","subCanvasX1","Infinity","subCanvasX2","subCanvasY1","subCanvasY2","max","tempCanvas","createElement","tempCanvasCtx","getContext","style","display","body","appendChild","drawImage","link","setAttribute","toDataURL","click","remove","exportAsPNG","Number","disabled","id","innerWidth","innerHeight","onWheel","deltaX","deltaY","onMouseDown","clientX","offsetLeft","clientY","offsetTop","newElement","isDraggingElements","cursorStyle","documentElement","cursor","hitElement","find","px","py","tx","ty","ex","ey","rx","ry","qx","qy","r","q","t","console","warn","hitTest","some","prompt","measureText","actualBoundingBoxDescent","lastX","lastY","onMouseMove","HTMLElement","selectedElements","el","selection","selectionX1","selectionX2","selectionY1","selectionY2","setSelection","onMouseUp","pop","setItem","React","Component","getElementById"],"mappings":"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","file":"static/js/main.5e8f5ec8.chunk.js","sourcesContent":["function swap<T>(elements: T[], indexA: number, indexB: number) {\n  const element = elements[indexA];\n  elements[indexA] = elements[indexB];\n  elements[indexB] = element;\n}\n\nexport function moveOneLeft<T>(elements: T[], indicesToMove: number[]) {\n  indicesToMove.sort((a: number, b: number) => a - b);\n  let isSorted = true;\n  // We go from left to right to avoid overriding the wrong elements\n  indicesToMove.forEach((index, i) => {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === i;\n    if (isSorted) {\n      return;\n    }\n    swap(elements, index - 1, index);\n  });\n}\n\n// Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [c, f, a, b, d, e, g]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the right.\n//\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//          -> ->\n//\n// which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//\n// Now, we need to move all the elements from marker 1 to the beginning by two (not one)\n// slots to the right, which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//  ---|--^  ^\n//     ------|\n//\n// which gives us\n//\n//        |1       |0\n// [_, _, a, b, d, e, g]\n//\n// At this point, we can fill back the leftmost elements with the array we saved at\n// the beggining\n//\n//        |1       |0\n// [c, f, a, b, d, e, g]\n//\n// And we are done!\nexport function moveAllLeft<T>(elements: T[], indicesToMove: number[]) {\n  indicesToMove.sort((a: number, b: number) => a - b);\n\n  // Copy the elements to move\n  const leftMostElements = indicesToMove.map(index => elements[index]);\n\n  const reversedIndicesToMove = indicesToMove\n    // We go from right to left to avoid overriding elements.\n    .reverse()\n    // We add 0 for the final marker\n    .concat([0]);\n\n  reversedIndicesToMove.forEach((index, i) => {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    }\n\n    // We go from the next marker to the right (i - 1) to the current one (index)\n    for (let pos = reversedIndicesToMove[i - 1] - 1; pos >= index; --pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos + i] = elements[pos];\n    }\n  });\n\n  // The final step\n  leftMostElements.forEach((element, i) => {\n    elements[i] = element;\n  });\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport rough from \"roughjs/bin/wrappers/rough\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  faMousePointer,\n  faSquare,\n  faCircle,\n  faLongArrowAltRight,\n  faFont\n} from \"@fortawesome/free-solid-svg-icons\";\n\nimport { moveOneLeft, moveAllLeft } from \"./zindex\";\n\nimport \"./styles.css\";\n\ntype ExcalidrawElement = ReturnType<typeof newElement>;\ntype ExcalidrawTextElement = ExcalidrawElement & {\n  type: \"text\";\n  font: string;\n  text: string;\n  actualBoundingBoxAscent: number;\n};\n\nconst LOCAL_STORAGE_KEY = \"excalidraw\";\nconst LOCAL_STORAGE_KEY_STATE = \"excalidraw-state\";\n\nlet elements = Array.of<ExcalidrawElement>();\n\n// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript/47593316#47593316\nconst LCG = (seed: number) => () =>\n  ((2 ** 31 - 1) & (seed = Math.imul(48271, seed))) / 2 ** 31;\n\nfunction randomSeed() {\n  return Math.floor(Math.random() * 2 ** 31);\n}\n\n// Unfortunately, roughjs doesn't support a seed attribute (https://github.com/pshihn/rough/issues/27).\n// We can achieve the same result by overriding the Math.random function with a\n// pseudo random generator that supports a random seed and swapping it back after.\nfunction withCustomMathRandom<T>(seed: number, cb: () => T): T {\n  const random = Math.random;\n  Math.random = LCG(seed);\n  const result = cb();\n  Math.random = random;\n  return result;\n}\n\n// https://stackoverflow.com/a/6853926/232122\nfunction distanceBetweenPointAndSegment(\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n) {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const lenSquare = C * C + D * D;\n  let param = -1;\n  if (lenSquare !== 0) {\n    // in case of 0 length line\n    param = dot / lenSquare;\n  }\n\n  let xx, yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.hypot(dx, dy);\n}\n\nfunction hitTest(element: ExcalidrawElement, x: number, y: number): boolean {\n  // For shapes that are composed of lines, we only enable point-selection when the distance\n  // of the click is less than x pixels of any of the lines that the shape is composed of\n  const lineThreshold = 10;\n\n  if (element.type === \"ellipse\") {\n    // https://stackoverflow.com/a/46007540/232122\n    const px = Math.abs(x - element.x - element.width / 2);\n    const py = Math.abs(y - element.y - element.height / 2);\n\n    let tx = 0.707;\n    let ty = 0.707;\n\n    const a = element.width / 2;\n    const b = element.height / 2;\n\n    [0, 1, 2, 3].forEach(x => {\n      const xx = a * tx;\n      const yy = b * ty;\n\n      const ex = ((a * a - b * b) * tx ** 3) / a;\n      const ey = ((b * b - a * a) * ty ** 3) / b;\n\n      const rx = xx - ex;\n      const ry = yy - ey;\n\n      const qx = px - ex;\n      const qy = py - ey;\n\n      const r = Math.hypot(ry, rx);\n      const q = Math.hypot(qy, qx);\n\n      tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n      ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n      const t = Math.hypot(ty, tx);\n      tx /= t;\n      ty /= t;\n    });\n\n    return Math.hypot(a * tx - px, b * ty - py) < lineThreshold;\n  } else if (element.type === \"rectangle\") {\n    const x1 = getElementAbsoluteX1(element);\n    const x2 = getElementAbsoluteX2(element);\n    const y1 = getElementAbsoluteY1(element);\n    const y2 = getElementAbsoluteY2(element);\n\n    // (x1, y1) --A-- (x2, y1)\n    //    |D             |B\n    // (x1, y2) --C-- (x2, y2)\n    return (\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y1) < lineThreshold || // A\n      distanceBetweenPointAndSegment(x, y, x2, y1, x2, y2) < lineThreshold || // B\n      distanceBetweenPointAndSegment(x, y, x2, y2, x1, y2) < lineThreshold || // C\n      distanceBetweenPointAndSegment(x, y, x1, y2, x1, y1) < lineThreshold // D\n    );\n  } else if (element.type === \"arrow\") {\n    let [x1, y1, x2, y2, x3, y3, x4, y4] = getArrowPoints(element);\n    // The computation is done at the origin, we need to add a translation\n    x -= element.x;\n    y -= element.y;\n\n    return (\n      //    \\\n      distanceBetweenPointAndSegment(x, y, x3, y3, x2, y2) < lineThreshold ||\n      // -----\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y2) < lineThreshold ||\n      //    /\n      distanceBetweenPointAndSegment(x, y, x4, y4, x2, y2) < lineThreshold\n    );\n  } else if (element.type === \"text\") {\n    const x1 = getElementAbsoluteX1(element);\n    const x2 = getElementAbsoluteX2(element);\n    const y1 = getElementAbsoluteY1(element);\n    const y2 = getElementAbsoluteY2(element);\n\n    return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n  } else if (element.type === \"selection\") {\n    console.warn(\"This should not happen, we need to investigate why it does.\");\n    return false;\n  } else {\n    throw new Error(\"Unimplemented type \" + element.type);\n  }\n}\n\nfunction newElement(\n  type: string,\n  x: number,\n  y: number,\n  strokeColor: string,\n  backgroundColor: string,\n  width = 0,\n  height = 0\n) {\n  const element = {\n    type: type,\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    isSelected: false,\n    strokeColor: strokeColor,\n    backgroundColor: backgroundColor,\n    seed: randomSeed(),\n    draw(\n      rc: RoughCanvas,\n      context: CanvasRenderingContext2D,\n      sceneState: SceneState\n    ) {}\n  };\n  return element;\n}\n\ntype SceneState = {\n  scrollX: number;\n  scrollY: number;\n  // null indicates transparent bg\n  viewBackgroundColor: string | null;\n};\n\nconst SCROLLBAR_WIDTH = 6;\nconst SCROLLBAR_MARGIN = 4;\nconst SCROLLBAR_COLOR = \"rgba(0,0,0,0.3)\";\n\nfunction getScrollbars(\n  canvasWidth: number,\n  canvasHeight: number,\n  scrollX: number,\n  scrollY: number\n) {\n  // horizontal scrollbar\n  const sceneWidth = canvasWidth + Math.abs(scrollX);\n  const scrollBarWidth = (canvasWidth * canvasWidth) / sceneWidth;\n  const scrollBarX = scrollX > 0 ? 0 : canvasWidth - scrollBarWidth;\n  const horizontalScrollBar = {\n    x: scrollBarX + SCROLLBAR_MARGIN,\n    y: canvasHeight - SCROLLBAR_WIDTH - SCROLLBAR_MARGIN,\n    width: scrollBarWidth - SCROLLBAR_MARGIN * 2,\n    height: SCROLLBAR_WIDTH\n  };\n\n  // vertical scrollbar\n  const sceneHeight = canvasHeight + Math.abs(scrollY);\n  const scrollBarHeight = (canvasHeight * canvasHeight) / sceneHeight;\n  const scrollBarY = scrollY > 0 ? 0 : canvasHeight - scrollBarHeight;\n  const verticalScrollBar = {\n    x: canvasWidth - SCROLLBAR_WIDTH - SCROLLBAR_MARGIN,\n    y: scrollBarY + SCROLLBAR_MARGIN,\n    width: SCROLLBAR_WIDTH,\n    height: scrollBarHeight - SCROLLBAR_WIDTH * 2\n  };\n\n  return {\n    horizontal: horizontalScrollBar,\n    vertical: verticalScrollBar\n  };\n}\n\nfunction renderScene(\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState\n) {\n  if (!context) return;\n\n  const fillStyle = context.fillStyle;\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(-0.5, -0.5, canvas.width, canvas.height);\n  } else {\n    context.clearRect(-0.5, -0.5, canvas.width, canvas.height);\n  }\n  context.fillStyle = fillStyle;\n\n  elements.forEach(element => {\n    element.draw(rc, context, sceneState);\n    if (element.isSelected) {\n      const margin = 4;\n\n      const elementX1 = getElementAbsoluteX1(element);\n      const elementX2 = getElementAbsoluteX2(element);\n      const elementY1 = getElementAbsoluteY1(element);\n      const elementY2 = getElementAbsoluteY2(element);\n      const lineDash = context.getLineDash();\n      context.setLineDash([8, 4]);\n      context.strokeRect(\n        elementX1 - margin + sceneState.scrollX,\n        elementY1 - margin + sceneState.scrollY,\n        elementX2 - elementX1 + margin * 2,\n        elementY2 - elementY1 + margin * 2\n      );\n      context.setLineDash(lineDash);\n    }\n  });\n\n  const scrollBars = getScrollbars(\n    context.canvas.width,\n    context.canvas.height,\n    sceneState.scrollX,\n    sceneState.scrollY\n  );\n\n  context.fillStyle = SCROLLBAR_COLOR;\n  context.fillRect(\n    scrollBars.horizontal.x,\n    scrollBars.horizontal.y,\n    scrollBars.horizontal.width,\n    scrollBars.horizontal.height\n  );\n  context.fillRect(\n    scrollBars.vertical.x,\n    scrollBars.vertical.y,\n    scrollBars.vertical.width,\n    scrollBars.vertical.height\n  );\n  context.fillStyle = fillStyle;\n}\n\nfunction exportAsPNG({\n  exportBackground,\n  exportVisibleOnly,\n  exportPadding = 10,\n  viewBackgroundColor\n}: {\n  exportBackground: boolean;\n  exportVisibleOnly: boolean;\n  exportPadding?: number;\n  viewBackgroundColor: string;\n}) {\n  if (!elements.length) return window.alert(\"Cannot export empty canvas.\");\n\n  // deselect & rerender\n\n  clearSelection();\n  ReactDOM.render(<App />, rootElement, () => {\n    // calculate visible-area coords\n\n    let subCanvasX1 = Infinity;\n    let subCanvasX2 = 0;\n    let subCanvasY1 = Infinity;\n    let subCanvasY2 = 0;\n\n    elements.forEach(element => {\n      subCanvasX1 = Math.min(subCanvasX1, getElementAbsoluteX1(element));\n      subCanvasX2 = Math.max(subCanvasX2, getElementAbsoluteX2(element));\n      subCanvasY1 = Math.min(subCanvasY1, getElementAbsoluteY1(element));\n      subCanvasY2 = Math.max(subCanvasY2, getElementAbsoluteY2(element));\n    });\n\n    // create temporary canvas from which we'll export\n\n    const tempCanvas = document.createElement(\"canvas\");\n    const tempCanvasCtx = tempCanvas.getContext(\"2d\")!;\n    tempCanvas.style.display = \"none\";\n    document.body.appendChild(tempCanvas);\n    tempCanvas.width = exportVisibleOnly\n      ? subCanvasX2 - subCanvasX1 + exportPadding * 2\n      : canvas.width;\n    tempCanvas.height = exportVisibleOnly\n      ? subCanvasY2 - subCanvasY1 + exportPadding * 2\n      : canvas.height;\n\n    // if we're exporting without bg, we need to rerender the scene without it\n    //  (it's reset again, below)\n    if (!exportBackground) {\n      renderScene(rc, context, {\n        viewBackgroundColor: null,\n        scrollX: 0,\n        scrollY: 0\n      });\n    }\n\n    // copy our original canvas onto the temp canvas\n    tempCanvasCtx.drawImage(\n      canvas, // source\n      exportVisibleOnly // sx\n        ? subCanvasX1 - exportPadding\n        : 0,\n      exportVisibleOnly // sy\n        ? subCanvasY1 - exportPadding\n        : 0,\n      exportVisibleOnly // sWidth\n        ? subCanvasX2 - subCanvasX1 + exportPadding * 2\n        : canvas.width,\n      exportVisibleOnly // sHeight\n        ? subCanvasY2 - subCanvasY1 + exportPadding * 2\n        : canvas.height,\n      0, // dx\n      0, // dy\n      exportVisibleOnly ? tempCanvas.width : canvas.width, // dWidth\n      exportVisibleOnly ? tempCanvas.height : canvas.height // dHeight\n    );\n\n    // reset transparent bg back to original\n    if (!exportBackground) {\n      renderScene(rc, context, { viewBackgroundColor, scrollX: 0, scrollY: 0 });\n    }\n\n    // create a temporary <a> elem which we'll use to download the image\n    const link = document.createElement(\"a\");\n    link.setAttribute(\"download\", \"excalidraw.png\");\n    link.setAttribute(\"href\", tempCanvas.toDataURL(\"image/png\"));\n    link.click();\n\n    // clean up the DOM\n    link.remove();\n    if (tempCanvas !== canvas) tempCanvas.remove();\n  });\n}\n\nfunction rotate(x1: number, y1: number, x2: number, y2: number, angle: number) {\n  // ð‘Žâ€²ð‘¥=(ð‘Žð‘¥âˆ’ð‘ð‘¥)cosðœƒâˆ’(ð‘Žð‘¦âˆ’ð‘ð‘¦)sinðœƒ+ð‘ð‘¥\n  // ð‘Žâ€²ð‘¦=(ð‘Žð‘¥âˆ’ð‘ð‘¥)sinðœƒ+(ð‘Žð‘¦âˆ’ð‘ð‘¦)cosðœƒ+ð‘ð‘¦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  return [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2\n  ];\n}\n\n// Casting second argument (DrawingSurface) to any,\n// because it is requred by TS definitions and not required at runtime\nconst generator = rough.generator(null, null as any);\n\nfunction isTextElement(\n  element: ExcalidrawElement\n): element is ExcalidrawTextElement {\n  return element.type === \"text\";\n}\n\nfunction getArrowPoints(element: ExcalidrawElement) {\n  const x1 = 0;\n  const y1 = 0;\n  const x2 = element.width;\n  const y2 = element.height;\n\n  const size = 30; // pixels\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  // Scale down the arrow until we hit a certain size so that it doesn't look weird\n  const minSize = Math.min(size, distance / 2);\n  const xs = x2 - ((x2 - x1) / distance) * minSize;\n  const ys = y2 - ((y2 - y1) / distance) * minSize;\n\n  const angle = 20; // degrees\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n\n  return [x1, y1, x2, y2, x3, y3, x4, y4];\n}\n\nfunction generateDraw(element: ExcalidrawElement) {\n  if (element.type === \"selection\") {\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(\n        element.x + scrollX,\n        element.y + scrollY,\n        element.width,\n        element.height\n      );\n      context.fillStyle = fillStyle;\n    };\n  } else if (element.type === \"rectangle\") {\n    const shape = withCustomMathRandom(element.seed, () => {\n      return generator.rectangle(0, 0, element.width, element.height, {\n        stroke: element.strokeColor,\n        fill: element.backgroundColor\n      });\n    });\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.translate(element.x + scrollX, element.y + scrollY);\n      rc.draw(shape);\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n    };\n  } else if (element.type === \"ellipse\") {\n    const shape = withCustomMathRandom(element.seed, () =>\n      generator.ellipse(\n        element.width / 2,\n        element.height / 2,\n        element.width,\n        element.height,\n        { stroke: element.strokeColor, fill: element.backgroundColor }\n      )\n    );\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.translate(element.x + scrollX, element.y + scrollY);\n      rc.draw(shape);\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n    };\n  } else if (element.type === \"arrow\") {\n    const [x1, y1, x2, y2, x3, y3, x4, y4] = getArrowPoints(element);\n    const shapes = withCustomMathRandom(element.seed, () => [\n      //    \\\n      generator.line(x3, y3, x2, y2, { stroke: element.strokeColor }),\n      // -----\n      generator.line(x1, y1, x2, y2, { stroke: element.strokeColor }),\n      //    /\n      generator.line(x4, y4, x2, y2, { stroke: element.strokeColor })\n    ]);\n\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      context.translate(element.x + scrollX, element.y + scrollY);\n      shapes.forEach(shape => rc.draw(shape));\n      context.translate(-element.x - scrollX, -element.y - scrollY);\n    };\n    return;\n  } else if (isTextElement(element)) {\n    element.draw = (rc, context, { scrollX, scrollY }) => {\n      const font = context.font;\n      context.font = element.font;\n      const fillStyle = context.fillStyle;\n      context.fillStyle = element.strokeColor;\n      context.fillText(\n        element.text,\n        element.x + scrollX,\n        element.y + element.actualBoundingBoxAscent + scrollY\n      );\n      context.fillStyle = fillStyle;\n      context.font = font;\n    };\n  } else {\n    throw new Error(\"Unimplemented type \" + element.type);\n  }\n}\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\n// We can't just always normalize it since we need to remember the fact that an arrow\n// is pointing left or right.\nfunction getElementAbsoluteX1(element: ExcalidrawElement) {\n  return element.width >= 0 ? element.x : element.x + element.width;\n}\nfunction getElementAbsoluteX2(element: ExcalidrawElement) {\n  return element.width >= 0 ? element.x + element.width : element.x;\n}\nfunction getElementAbsoluteY1(element: ExcalidrawElement) {\n  return element.height >= 0 ? element.y : element.y + element.height;\n}\nfunction getElementAbsoluteY2(element: ExcalidrawElement) {\n  return element.height >= 0 ? element.y + element.height : element.y;\n}\n\nfunction setSelection(selection: ExcalidrawElement) {\n  const selectionX1 = getElementAbsoluteX1(selection);\n  const selectionX2 = getElementAbsoluteX2(selection);\n  const selectionY1 = getElementAbsoluteY1(selection);\n  const selectionY2 = getElementAbsoluteY2(selection);\n  elements.forEach(element => {\n    const elementX1 = getElementAbsoluteX1(element);\n    const elementX2 = getElementAbsoluteX2(element);\n    const elementY1 = getElementAbsoluteY1(element);\n    const elementY2 = getElementAbsoluteY2(element);\n    element.isSelected =\n      element.type !== \"selection\" &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2;\n  });\n}\n\nfunction clearSelection() {\n  elements.forEach(element => {\n    element.isSelected = false;\n  });\n}\n\nfunction deleteSelectedElements() {\n  for (let i = elements.length - 1; i >= 0; --i) {\n    if (elements[i].isSelected) {\n      elements.splice(i, 1);\n    }\n  }\n}\n\nfunction save(state: AppState) {\n  localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(elements));\n  localStorage.setItem(LOCAL_STORAGE_KEY_STATE, JSON.stringify(state));\n}\n\nfunction restore() {\n  try {\n    const savedElements = localStorage.getItem(LOCAL_STORAGE_KEY);\n    const savedState = localStorage.getItem(LOCAL_STORAGE_KEY_STATE);\n\n    if (savedElements) {\n      elements = JSON.parse(savedElements);\n      elements.forEach((element: ExcalidrawElement) => generateDraw(element));\n    }\n\n    return savedState ? JSON.parse(savedState) : null;\n  } catch (e) {\n    elements = [];\n    return null;\n  }\n}\n\ntype AppState = {\n  draggingElement: ExcalidrawElement | null;\n  elementType: string;\n  exportBackground: boolean;\n  exportVisibleOnly: boolean;\n  exportPadding: number;\n  currentItemStrokeColor: string;\n  currentItemBackgroundColor: string;\n  viewBackgroundColor: string;\n  scrollX: number;\n  scrollY: number;\n};\n\nconst KEYS = {\n  ARROW_LEFT: \"ArrowLeft\",\n  ARROW_RIGHT: \"ArrowRight\",\n  ARROW_DOWN: \"ArrowDown\",\n  ARROW_UP: \"ArrowUp\",\n  ESCAPE: \"Escape\",\n  DELETE: \"Delete\",\n  BACKSPACE: \"Backspace\"\n};\n\nconst SHAPES = [\n  {\n    icon: faMousePointer,\n    value: \"selection\"\n  },\n  {\n    icon: faSquare,\n    value: \"rectangle\"\n  },\n  {\n    icon: faCircle,\n    value: \"ellipse\"\n  },\n  {\n    icon: faLongArrowAltRight,\n    value: \"arrow\"\n  },\n  {\n    icon: faFont,\n    value: \"text\"\n  }\n];\n\nconst shapesShortcutKeys = SHAPES.map(shape => shape.value[0]);\n\nfunction findElementByKey(key: string) {\n  const defaultElement = \"selection\";\n  return SHAPES.reduce((element, shape) => {\n    if (shape.value[0] !== key) return element;\n\n    return shape.value;\n  }, defaultElement);\n}\n\nfunction isArrowKey(keyCode: string) {\n  return (\n    keyCode === KEYS.ARROW_LEFT ||\n    keyCode === KEYS.ARROW_RIGHT ||\n    keyCode === KEYS.ARROW_DOWN ||\n    keyCode === KEYS.ARROW_UP\n  );\n}\n\nfunction getSelectedIndices() {\n  const selectedIndices: number[] = [];\n  elements.forEach((element, index) => {\n    if (element.isSelected) {\n      selectedIndices.push(index);\n    }\n  });\n  return selectedIndices;\n}\n\nconst ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;\nconst ELEMENT_TRANSLATE_AMOUNT = 1;\n\nclass App extends React.Component<{}, AppState> {\n  public componentDidMount() {\n    document.addEventListener(\"keydown\", this.onKeyDown, false);\n    window.addEventListener(\"resize\", this.onResize, false);\n\n    const savedState = restore();\n    if (savedState) {\n      this.setState(savedState);\n    }\n  }\n\n  public componentWillUnmount() {\n    document.removeEventListener(\"keydown\", this.onKeyDown, false);\n    window.removeEventListener(\"resize\", this.onResize, false);\n  }\n\n  public state: AppState = {\n    draggingElement: null,\n    elementType: \"selection\",\n    exportBackground: false,\n    exportVisibleOnly: true,\n    exportPadding: 10,\n    currentItemStrokeColor: \"#000000\",\n    currentItemBackgroundColor: \"#ffffff\",\n    viewBackgroundColor: \"#ffffff\",\n    scrollX: 0,\n    scrollY: 0\n  };\n\n  private onResize = () => {\n    this.forceUpdate();\n  };\n\n  private onKeyDown = (event: KeyboardEvent) => {\n    if ((event.target as HTMLElement).nodeName === \"INPUT\") {\n      return;\n    }\n\n    if (event.key === KEYS.ESCAPE) {\n      clearSelection();\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) {\n      deleteSelectedElements();\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (isArrowKey(event.key)) {\n      const step = event.shiftKey\n        ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n        : ELEMENT_TRANSLATE_AMOUNT;\n      elements.forEach(element => {\n        if (element.isSelected) {\n          if (event.key === KEYS.ARROW_LEFT) element.x -= step;\n          else if (event.key === KEYS.ARROW_RIGHT) element.x += step;\n          else if (event.key === KEYS.ARROW_UP) element.y -= step;\n          else if (event.key === KEYS.ARROW_DOWN) element.y += step;\n        }\n      });\n      this.forceUpdate();\n      event.preventDefault();\n\n      // Send backwards: Cmd-Shift-Alt-B\n    } else if (\n      event.metaKey &&\n      event.shiftKey &&\n      event.altKey &&\n      event.code === \"KeyB\"\n    ) {\n      moveOneLeft(elements, getSelectedIndices());\n      this.forceUpdate();\n      event.preventDefault();\n\n      // Send to back: Cmd-Shift-B\n    } else if (event.metaKey && event.shiftKey && event.code === \"KeyB\") {\n      moveAllLeft(elements, getSelectedIndices());\n      this.forceUpdate();\n      event.preventDefault();\n\n      // Select all: Cmd-A\n    } else if (event.metaKey && event.code === \"KeyA\") {\n      elements.forEach(element => {\n        element.isSelected = true;\n      });\n      this.forceUpdate();\n      event.preventDefault();\n    } else if (shapesShortcutKeys.includes(event.key.toLowerCase())) {\n      this.setState({ elementType: findElementByKey(event.key) });\n    }\n  };\n\n  public render() {\n    return (\n      <div\n        className=\"container\"\n        onCut={e => {\n          e.clipboardData.setData(\n            \"text/plain\",\n            JSON.stringify(elements.filter(element => element.isSelected))\n          );\n          deleteSelectedElements();\n          this.forceUpdate();\n          e.preventDefault();\n        }}\n        onCopy={e => {\n          e.clipboardData.setData(\n            \"text/plain\",\n            JSON.stringify(elements.filter(element => element.isSelected))\n          );\n          e.preventDefault();\n        }}\n        onPaste={e => {\n          const paste = e.clipboardData.getData(\"text\");\n          let parsedElements;\n          try {\n            parsedElements = JSON.parse(paste);\n          } catch (e) {}\n          if (\n            Array.isArray(parsedElements) &&\n            parsedElements.length > 0 &&\n            parsedElements[0].type // need to implement a better check here...\n          ) {\n            clearSelection();\n            parsedElements.forEach(parsedElement => {\n              parsedElement.x += 10;\n              parsedElement.y += 10;\n              parsedElement.seed = randomSeed();\n              generateDraw(parsedElement);\n              elements.push(parsedElement);\n            });\n            this.forceUpdate();\n          }\n          e.preventDefault();\n        }}\n      >\n        <div className=\"sidePanel\">\n          <h4>Shapes</h4>\n          <div className=\"panelTools\">\n            {SHAPES.map(({ value, icon }) => (\n              <label key={value} className=\"tool\">\n                <input\n                  type=\"radio\"\n                  checked={this.state.elementType === value}\n                  onChange={() => {\n                    this.setState({ elementType: value });\n                    clearSelection();\n                    this.forceUpdate();\n                  }}\n                />\n                <div className=\"toolIcon\">\n                  <FontAwesomeIcon icon={icon} />\n                </div>\n              </label>\n            ))}\n          </div>\n          <h4>Colors</h4>\n          <div className=\"panelColumn\">\n            <label>\n              <input\n                type=\"color\"\n                value={this.state.viewBackgroundColor}\n                onChange={e => {\n                  this.setState({ viewBackgroundColor: e.target.value });\n                }}\n              />\n              Background\n            </label>\n            <label>\n              <input\n                type=\"color\"\n                value={this.state.currentItemStrokeColor}\n                onChange={e => {\n                  this.setState({ currentItemStrokeColor: e.target.value });\n                }}\n              />\n              Shape Stroke\n            </label>\n            <label>\n              <input\n                type=\"color\"\n                value={this.state.currentItemBackgroundColor}\n                onChange={e => {\n                  this.setState({ currentItemBackgroundColor: e.target.value });\n                }}\n              />\n              Shape Background\n            </label>\n          </div>\n          <h4>Export</h4>\n          <div className=\"panelColumn\">\n            <button\n              onClick={() => {\n                exportAsPNG({\n                  exportBackground: this.state.exportBackground,\n                  exportVisibleOnly: this.state.exportVisibleOnly,\n                  exportPadding: this.state.exportPadding,\n                  viewBackgroundColor: this.state.viewBackgroundColor\n                });\n              }}\n            >\n              Export to png\n            </button>\n            <label>\n              <input\n                type=\"checkbox\"\n                checked={this.state.exportBackground}\n                onChange={e => {\n                  this.setState({ exportBackground: e.target.checked });\n                }}\n              />\n              background\n            </label>\n            <label>\n              <input\n                type=\"checkbox\"\n                checked={this.state.exportVisibleOnly}\n                onChange={e => {\n                  this.setState({ exportVisibleOnly: e.target.checked });\n                }}\n              />\n              visible area only\n            </label>\n            <div>\n              (padding:\n              <input\n                type=\"number\"\n                value={this.state.exportPadding}\n                onChange={e => {\n                  this.setState({ exportPadding: Number(e.target.value) });\n                }}\n                disabled={!this.state.exportVisibleOnly}\n              />\n              px)\n            </div>\n          </div>\n        </div>\n        <canvas\n          id=\"canvas\"\n          width={window.innerWidth - 250}\n          height={window.innerHeight}\n          onWheel={e => {\n            e.preventDefault();\n            const { deltaX, deltaY } = e;\n            this.setState(state => ({\n              scrollX: state.scrollX - deltaX,\n              scrollY: state.scrollY - deltaY\n            }));\n          }}\n          onMouseDown={e => {\n            const x =\n              e.clientX -\n              (e.target as HTMLElement).offsetLeft -\n              this.state.scrollX;\n            const y =\n              e.clientY -\n              (e.target as HTMLElement).offsetTop -\n              this.state.scrollY;\n            const element = newElement(\n              this.state.elementType,\n              x,\n              y,\n              this.state.currentItemStrokeColor,\n              this.state.currentItemBackgroundColor\n            );\n            let isDraggingElements = false;\n            const cursorStyle = document.documentElement.style.cursor;\n            if (this.state.elementType === \"selection\") {\n              const hitElement = elements.find(element => {\n                return hitTest(element, x, y);\n              });\n\n              // If we click on something\n              if (hitElement) {\n                if (hitElement.isSelected) {\n                  // If that element is not already selected, do nothing,\n                  // we're likely going to drag it\n                } else {\n                  // We unselect every other elements unless shift is pressed\n                  if (!e.shiftKey) {\n                    clearSelection();\n                  }\n                  // No matter what, we select it\n                  hitElement.isSelected = true;\n                }\n              } else {\n                // If we don't click on anything, let's remove all the selected elements\n                clearSelection();\n              }\n\n              isDraggingElements = elements.some(element => element.isSelected);\n\n              if (isDraggingElements) {\n                document.documentElement.style.cursor = \"move\";\n              }\n            }\n\n            if (isTextElement(element)) {\n              const text = prompt(\"What text do you want?\");\n              if (text === null) {\n                return;\n              }\n              element.text = text;\n              element.font = \"20px Virgil\";\n              const font = context.font;\n              context.font = element.font;\n              const {\n                actualBoundingBoxAscent,\n                actualBoundingBoxDescent,\n                width\n              } = context.measureText(element.text);\n              element.actualBoundingBoxAscent = actualBoundingBoxAscent;\n              context.font = font;\n              const height = actualBoundingBoxAscent + actualBoundingBoxDescent;\n              // Center the text\n              element.x -= width / 2;\n              element.y -= actualBoundingBoxAscent;\n              element.width = width;\n              element.height = height;\n            }\n\n            generateDraw(element);\n            elements.push(element);\n            if (this.state.elementType === \"text\") {\n              this.setState({\n                draggingElement: null,\n                elementType: \"selection\"\n              });\n              element.isSelected = true;\n            } else {\n              this.setState({ draggingElement: element });\n            }\n\n            let lastX = x;\n            let lastY = y;\n\n            const onMouseMove = (e: MouseEvent) => {\n              const target = e.target;\n              if (!(target instanceof HTMLElement)) {\n                return;\n              }\n\n              if (isDraggingElements) {\n                const selectedElements = elements.filter(el => el.isSelected);\n                if (selectedElements.length) {\n                  const x = e.clientX - target.offsetLeft - this.state.scrollX;\n                  const y = e.clientY - target.offsetTop - this.state.scrollY;\n                  selectedElements.forEach(element => {\n                    element.x += x - lastX;\n                    element.y += y - lastY;\n                  });\n                  lastX = x;\n                  lastY = y;\n                  this.forceUpdate();\n                  return;\n                }\n              }\n\n              // It is very important to read this.state within each move event,\n              // otherwise we would read a stale one!\n              const draggingElement = this.state.draggingElement;\n              if (!draggingElement) return;\n              let width =\n                e.clientX -\n                target.offsetLeft -\n                draggingElement.x -\n                this.state.scrollX;\n              let height =\n                e.clientY -\n                target.offsetTop -\n                draggingElement.y -\n                this.state.scrollY;\n              draggingElement.width = width;\n              // Make a perfect square or circle when shift is enabled\n              draggingElement.height = e.shiftKey ? width : height;\n\n              generateDraw(draggingElement);\n\n              if (this.state.elementType === \"selection\") {\n                setSelection(draggingElement);\n              }\n              this.forceUpdate();\n            };\n\n            const onMouseUp = (e: MouseEvent) => {\n              const { draggingElement, elementType } = this.state;\n\n              window.removeEventListener(\"mousemove\", onMouseMove);\n              window.removeEventListener(\"mouseup\", onMouseUp);\n\n              document.documentElement.style.cursor = cursorStyle;\n\n              // if no element is clicked, clear the selection and redraw\n              if (draggingElement === null) {\n                clearSelection();\n                this.forceUpdate();\n                return;\n              }\n\n              if (elementType === \"selection\") {\n                if (isDraggingElements) {\n                  isDraggingElements = false;\n                }\n                elements.pop();\n              } else {\n                draggingElement.isSelected = true;\n              }\n\n              this.setState({\n                draggingElement: null,\n                elementType: \"selection\"\n              });\n              this.forceUpdate();\n            };\n\n            window.addEventListener(\"mousemove\", onMouseMove);\n            window.addEventListener(\"mouseup\", onMouseUp);\n\n            this.forceUpdate();\n          }}\n        />\n      </div>\n    );\n  }\n\n  componentDidUpdate() {\n    renderScene(rc, context, {\n      scrollX: this.state.scrollX,\n      scrollY: this.state.scrollY,\n      viewBackgroundColor: this.state.viewBackgroundColor\n    });\n    save(this.state);\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\nconst canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\nconst rc = rough.canvas(canvas);\nconst context = canvas.getContext(\"2d\")!;\n\n// Big hack to ensure that all the 1px lines are drawn at 1px instead of 2px\n// https://stackoverflow.com/questions/13879322/drawing-a-1px-thick-line-in-canvas-creates-a-2px-thick-line/13879402#comment90766599_13879402\ncontext.translate(0.5, 0.5);\n\nReactDOM.render(<App />, rootElement);\n"],"sourceRoot":""}